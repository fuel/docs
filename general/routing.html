<!doctype html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./../assets/css/combined.css?20190627">
	<link rel="shortcut icon" href="./../favicon.ico" />
	<script src="https://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../';
	</script>
	<script src="./../assets/js/combined.js?20190627"></script>
	<title>ルーティング - 概要 - FuelPHP ドキュメント</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<div id="cse">
					<gcse:searchbox-only newWindow="true"></gcse:searchbox-only>
				</div>
				<h1>
					<a href="https://fuelphp.com"><img height="37px" width="147px" src="./../assets/img/fuel.png" /></a>
					<strong>Documentation</strong>
				</h1>

			</div>
			<nav>
				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">目次</a>
			<div class="clear"></div>
		</header>

		<div id="main">

			<h2>ルーティング</h2>

			<p>Fuel では、単純な静的なルート設定から HTTP の動詞によるルーティングを用いた高度なルート設定に至るまで、様々なルーティングが可能です。</p>

			<p>ルート設定は、<kbd>fuel/app/config/routes.php</kbd> で行います。</p>

			<h3 id="reserved">予約済みルート</h3>

			<p>Fuel では次の4つの予約済みルート設定があります。<kbd>_root_</kbd>, <kbd>_403_</kbd>, <kbd>_404_</kbd>, <kbd>_500_</kbd>.</p>

			<ul>
				<li><kbd>_root_</kbd> - URI が指定されなかったときのデフォルトルート。</li>
				<li><kbd>_403_</kbd> - アプリケーションが投げた HttpNoAccessException がキャッチされなかったときに使われるルート。</li>
				<li><kbd>_404_</kbd> - アプリケーションが投げた HttpNotFoundException がキャッチされなかったときに使われるルート。</li>
				<li><kbd>_500_</kbd> - アプリケーションが投げた HttpServerErrorException がキャッチされなかったときに使われるルート。</li>
			</ul>

			<p class="note">
				リクエストした URI （ルーティング）がアプリケーション内で解決できないとき、
				request クラスが HttpNotFoundException を投げます。
			</p>
			<p class="note">
				<kbd>_404_</kbd> ルートが未定義の場合、フレームワーク自身のエラーハンドラを使って "page not found" メッセージが表示されます。
				<kbd>_403_</kbd> または <kbd>_500_</kbd> ルートが未定義の場合、
				これらの例外はキャッチされないまま、あなたのアプリケーションが投げる他の例外と同様に処理されます。
			</p>

			<pre class="php"><code>return array(
    '_root_'  => 'welcome/index',
    '_404_'   => 'welcome/404',
);</code></pre>

			<h3 id="basics">基本的なルーティング</h3>

			<p>左辺に記述されたルートは、リクエストされた URI と比較されます。もし一致していれば、そのリクエストは右辺の URI に経路づけられます。</p>

			<p>このルーティングによって、次のようなことが可能になります。:</p>

			<pre class="php"><code>return array(
    'about'   => 'site/about',
    'contact' => 'contact/form',
    'admin'   => 'admin/login',
);</code></pre>


			<h3 id="slightly_advanced">やや高度なルーティング</h3>

			<p>ルート設定には正規表現を含めることが出来ます。
			左辺とリクエストされた URI が一致したら、その一致した部分を右辺に代入するといったような、
			左辺の正規表現による右辺の後方参照が利用可能です。また、次のようないくつかの特別な宣言があり、それを用いて何かに一致させたり、
			あるいは特定セグメントに一致させたりすることが出来ます。</p>

			<ul>
				<li><kbd>:any</kbd> - URI の任意の部分と一致、"何もない" には一致しない</li>
				<li><kbd>:everything</kbd> - <kbd>:any</kbd> と同様、しかし "何もない" にも一致</li>
				<li><kbd>:segment</kbd> - URI の 1 つのセグメントのみに一致、しかしそのセグメントは任意のものであっていい</li>
				<li><kbd>:num</kbd> - 任意の数値と一致</li>
				<li><kbd>:alpha</kbd> - UTF-8 を含む、任意のアルファベットと一致</li>
				<li><kbd>:alnum</kbd> - UTF-8 を含む、任意のアルファベットや数字と一致</li>
			</ul>

			<p>ここにいくつかの例があります。 <kbd>:any</kbd> と <kbd>:everything</kbd> の間の微妙な違いに注意:</p>

			<pre class="php"><code>return array(
    'blog/(:any)'       => 'blog/entry/$1', // /blog/entry_name が /blog/entry/entry_name に経路付けられ、
                                            //   /blog/ と一致します。 /blogging や /blog とは一致しません。
    'blog(:any)'        => 'blog/entry$1',  // /blog/entry_name が /blog/entry/entry_name に経路付けられ、
                                            //   /blog/ や /blogging と一致します。 /blog とは一致しません。
    'blog(:everything)' => 'blog/entry$1',  // /blog/entry_name が /blog/entry/entry_name に経路付けられ、
                                            //   /blog/ 、 /blogging や /blog と一致します。
    '(:segment)/about'  => 'site/about/$1', // /en/about が /site/about/en に経路付けられる
    '(\d{2})/about'     => 'site/about/$1', // /12/about が /site/about/12 に経路付けられる
);</code></pre>


			<h3 id="advanced">高度なルーティング</h3>

			<p>ルート設定では、名前付きパラメータを使えます。これより、URI セグメントに対して名前を与えることができ、
			アクションメソッドの中でアクセスできます。</p>

			<p>例:</p>

			<pre class="php"><code>return array(
    'blog/:year/:month/:id' => 'blog/entry', // /blog/2010/11/entry_name が /blog/entry に経路付けられる
);</code></pre>

			<p>上の例では、<kbd>/blog/2010/11/entry_name</kbd> が捕捉され、
			'blog' コントローラ内の 'entry' アクションにルーティングされます。
			そこでは、下記のような名前付きパラメータを使うことができます。:</p>

			<pre class="php"><code>$this->param('year');
$this->param('month');
$this->param('id');</code></pre>

			<p class="note">
				名前付きパラメータは正規表現で、後方参照として数えられることに注意しましょう。
				例えば ':name/(\d{2})' において、2 桁の数字への後方参照は $2 であって、$1 ではありません。</p>


			<h3 id="http_verb">HTTP の動詞によるルーティング</h3>

			<p>アクセスされた HTTP の動詞に基づいて、URL をコントローラとアクションに経路付けることができます。
			このことによって、素早く簡単に RESTful なコントローラを作成できます。</p>

			<p>例:</p>

			<pre class="php"><code>return array(
    // GET /blog が /blog/all に、POST /blog が /blog/create に経路付けられる
    'blog' => array(array('GET', new Route('blog/all')), array('POST', new Route('blog/create'))),
);</code></pre>

			<p>URL には、名前付きパラメータと正規表現を普通に使えます:</p>

	        <pre class="php"><code>return array(
    'blog/(:any)' => array(array('GET', new Route('blog/show/$1'))),
);</code></pre>

			<p>3 つめパラメータに <kbd>false</kbd> あるいは <kbd>true</kbd> を渡すことで、ルートが HTTP のみをサポートするのか、あるいは HTTPS のみをサポートするのかを指定することもできます。</p>

	        <pre class="php"><code>// HTTPS のリクエストであった場合のみルートが有効になります
return array(
    'blog/(:any)' => array(array('GET', new Route('blog/show/$1'), true)),
);</code></pre>


			<h3 id="named_routes">名前付きルートとリバースルーティング</h3>

			<p>リバースルーティングというのは、次のような考え方を指します。たとえば管理エリアを作ろうとし、そのルートをセットアップします。
			ビューにおいて、管理エリアで例えば 'admin/start/overview' という HTML アンカーを使いたいとしましょう。
			ところが、気が変わって、そのページを 'admin/overview' という風に変えることにします。
			その結果、全てのビューで、そのリンクを更新しなければならなくなってしまいました...</p>

			<p>名前付きルートとリバースルーティングを用いると、名前付きルートをアンカーリンクにすることができ、
			ルートが変わっても、各ビューの中でのリンクはその変更を自動的に追随します。</p>

			<p>ルートの例:</p>

			<pre class="php"><code>return array(
    'admin/start/overview' => array('admin/overview', 'name' => 'admin_overview'), // admin/overview ページに対して名前付きルート名を追加する
);</code></pre>

			<p>アンカーの例:</p>

			<pre class="php"><code>// &lt;a href="http://your_base_url/admin/start/overview"&gt;Overview&lt;/a&gt; を生成する
echo Html::anchor(Router::get('admin_overview'), 'Overview');</code></pre>

			<p class="note">
				今のところ、 <kbd>app/config/routes.php</kbd> に定義されているルートのみで動作することに注意しましょう。モジュールのルートでは動作しません。
			</p>

			<h3 id="inline_routes">インラインルート</h3>

			<p>
				ルートはコントローラのメソッドに解決される必要はありません。 FuelPHP はコントローラメソッドを置き換える Closure として定義される
				インラインルートもサポートします。コントローラのメソッドと同様にインラインルートは Response オブジェクト を返さなければなりません。
				この Response オブジェクトは 自分で forge するか、 forge された Request を実行した結果として返します。
			</p>

			<p>ルートの例:</p>

			<pre class="php"><code>return array(
    'secret/mystuff' => function () {
		// このルートは development 環境でのみ動作します
		if (\Fuel::$env == \Fuel::DEVELOPMENT)
		{
			return \Request::forge('secret/mystuff/keepout', false)->execute();
		}
		else
		{
			throw new HttpNotFoundException('This page is only accessable in development.');
		}
};</code></pre>

			<h3 id="module_routing">モジュールとルーティング</h3>

			<p><a href="modules.html#module_routing">モジュールがどのようにルーティングを扱うか</a> をお読みください。</p>

		</div>

		<footer>
			<p>
				&copy; FuelPHP Development Team 2010-2019 - <a href="http://fuelphp.com">FuelPHP</a> is released under the MIT license.
[ <a href="https://github.com/fuel/docs/commits/1.8/master/general/routing.html">原文コミット履歴</a> | <a href="https://github.com/NEKOGET/FuelPHP_docs_jp/commits/1.8/master_japanese/general/routing.html">翻訳コミット履歴</a> | <a href="https://github.com/NEKOGET/FuelPHP_docs_jp/blob/1.8/develop_japanese/general/routing.html">GitHubで修正</a> ]
			</p>
		</footer>
	</div>
</body>
</html>
